#!/usr/bin/env python3
import re
import sys
import argparse

usage = "this script is to extract ref/query coordinative position, you'd better\n" +\
        "use one to one coords alignment which generated by *.1coords file.\n"

parser = argparse.ArgumentParser(description=usage,
                                formatter_class=argparse.RawTextHelpFormatter)

parser.add_argument("-in", metavar='<File>', type=str, dest='infile', required=True,
                   help='input file, aligned fasta')
parser.add_argument("-out", metavar='<STR>', type=str, dest='outpre', default='out',
                   help='out prefix for output files, default=out')
parser.add_argument("-size", metavar='<INT>', type=int, dest='productLen',
                   help='amplicon length you expected, default=500', default=500)
parser.add_argument("-plen", metavar='<INT>', type=int, dest='primerLen',
                   help='primer length you expected, default=25', default=25)
parser.add_argument("-step", metavar='<INT>', type=int, dest='step',
                   help='step length when scaning the alignment, default=1', default=1)
if len(sys.argv) == 1:
    parser.print_help()
    parser.exit()

args = parser.parse_args()

def get_phase(string):
    # string is like: --   END alignment [ +1 5334 - 61486 | +1 4 - 56173 ]
    # and get numer '5334' and '4'
    pattern = re.compile(r'(\d+) -')
    phase = {}
    m = pattern.findall(string)
    if m:
        phase['mat'] = m[0]
        phase['pat'] = m[1]

    return phase


def get_alignment(fp):
    name, seq = None, []
    for line in fp:
        line = line.strip()
        if line.startswith(">"):
            if name:
                yield (name.replace(">", ""), ''.join(seq))
            name, seq = line, []
        else:
            seq.append(line)
    if name:
        yield (name.replace(">", ""), ''.join(seq))


def slide_win(aln, win_len, step):
    alignment_len = len(list(aln.values())[0])
    # init phase 0
    i = 0
    tmp_aln = {}
    while i < alignment_len - win_len:
        for k in aln.keys():
            tmp_aln[k] = aln[k][i:i+win_len]
            print(str(i))
            yield tmp_aln, i
            i += step

def reverse_complementation(sequence):
    sequence = sequence.upper()
    transtable = str.maketrans('ATCG-', 'TAGC-')
    sequence = sequence.translate(transtable)
    return sequence[::-1]


def matched(s1, s2, length):
        matches = 0
        for i in range(length):
            if s1[i] == s2[i]:
                matches += 1
        return matches / length

def ployN(seq):
    import re
    pa = re.compile(r'A{4,}')
    pt = re.compile(r'T{4,}')
    pc = re.compile(r'C{4,}')
    pg = re.compile(r'G{4,}')
    if pa.search(seq) or pt.search(seq) or pc.search(seq) or pg.search(seq):
        return True
    else:
        return False

def check_hairpin(seq):
    seq_len = len(seq)
    min_stem = 5
    loop_start = range(0, seq_len - 2 * min_stem)
    hair_stem = range(min_stem, int(seq_len/2))
    """
    6789,10,11,12,13
    atcg,a, g, a, g, ggggt
    |||
    tagg c
    5432 1
    """
    signal = 0
    for s in loop_start:
        for h in hair_stem:
            if s+h < seq_len and s+2*h < seq_len:
                str1 = seq[s:s+h]
                str2 = seq[h:s+2*h]
                # be careful, 
                if matched(str1, reverse_complementation(str2), h) > 0.5:
                    signal = 1
                    return True
    if signal == 0:
        return False

def cross_match(primer1, primer2):
    """
    atcgagagggggt
       | |||||| |
    taggcgaggggat
    """
    min_align = 6
    signal = 0
    for i in range(5,len(primer1)):
        s1 = primer1[-i:]
        s2 = primer2[0:i]
        s3 = primer1[0:i]
        s4 = primer2[-i:]
        if matched(s1, s2, i) >= 0.5 or matched(s3, s4, i) >= 0.5:
            signal = 1
            break
    if signal == 1:
        return True # this is a cross match (reverse compliment)
    else:
        return False

def check_Tm(primer):
    a = primer.count("A")
    t = primer.count("T")
    c = primer.count("C")
    g = primer.count("G")
    gc_content = (g + c) / len(primer)
    tm = 2 * (a + t) + 4 * (g + c)
    if gc_content < 0.4 or gc_content > 0.6:
        return False
    elif tm < 50 or tm > 70:
        return False
    else:
        return True

def consensus(seqs):
    cons = ""
    for i in range(len(seqs[0])):
        tmp = {'A': 0,
               'T': 0,
               'C': 0,
               'G': 0,
               '-': 0}
        for s in seqs:
            tmp[s[i]] += 1
        sorted_base = sorted(tmp, key=lambda k: tmp[k], reverse=True)
        cons += sorted_base[0]
    return cons

class Amplicon():
    def __init__(self, alignment, phase, product_len, primer_len):
        self.alignment = alignment
        self.start = phase
        self.product_len = product_len
        self.primer_len = primer_len


    def forward_primer(self):
        forwards = []
        for k in self.alignment.keys():
            if '-' in self.alignment[k][0:self.primer_len]:
                return False
            else:
                forwards.append(self.alignment[k][0:self.primer_len])
                return consensus(forwards)


    def reverse_primer(self):
        reverses = []
        for k in self.alignment.keys():
            if '-' in self.alignment[k][-self.primer_len:]:
                return False
            else:
                reverses.append(self.alignment[k][-self.primer_len:])
                return consensus(reverses)

    def get_primer(self):
        #products = []
        #for p in self.alignment.keys():
            #print(self.alignment[p])
            #products.append(self.alignment[p][self.primer_len:-self.primer_len])

        #product = consensus(products)
        mstart = self.start

        forPrimer = self.forward_primer()
        revPrimer = self.reverse_primer()
        if forPrimer and revPrimer:
            revPrimer_start = self.start + self.product_len

            if ployN(forPrimer) == True or ployN(revPrimer) == True:
                return False
            elif check_hairpin(forPrimer) == True or check_hairpin(revPrimer) == True:
                return False
            elif check_Tm(forPrimer) == False or check_Tm(revPrimer) == False:
                return False
            elif cross_match(forPrimer, revPrimer) == True:
                return False
            else:
                #print(forPrimer + "\t" + revPrimer)
                return mstart, forPrimer, revPrimer_start, revPrimer

def main():
    allseqs = {}
    log = open(args.outpre + ".primer.design.log", 'w')
    with open(args.infile, 'r') as fh, open(args.outpre + ".primes", 'w') as fw:
        # save all sequences in a dict
        for name,seq in get_alignment(fh):
            allseqs[name] = seq

        pcr_size = 2 * args.primerLen + args.productLen
        for win, phase in slide_win(allseqs, pcr_size, args.step):
            amplicon = Amplicon(win, phase, args.productLen, args.primerLen)
            if amplicon.get_primer():
                mstart, forPrimer, revPrimer_start, revPrimer = amplicon.get_primer()
                print("F-" + str(mstart) + ": " + forPrimer + ", " +\
                      "R-" + str(revPrimer_start) + ": " + revPrimer + "\t", file=fw)
    log.close()

if __name__ == '__main__':
    main()
